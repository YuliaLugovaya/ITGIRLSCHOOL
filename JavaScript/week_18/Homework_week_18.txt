Неделя 18


Вопросы


1. Чем отличаются куки, localStorage и sessionStorage? Что стоит использовать, если нам нужно надолго сохранить много пользовательских данных?

a. Хранение. 
Local Storage хранит данные бессрочно, очищается только с помощью JavaScript или очистки кэша браузера.
Session Storage хранит данные, пока продолжается текущая сессия, и когда пользователь закрывает браузер, данные становятся недоступными; 
используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные. 
Cookie хранит данные, которые можно передавать на сервер через заголовки, срок хранения устанавливается при создании cookie.

b. Объём данных. 
Local Storage хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища. 
Session Storage хранит данные объёмом больше чем в Cookie. 
Cookie хранит данные объёмом не более 4 Кбайт.

c. Доступ. Локальное и сессионное хранилище доступны только на клиентской стороне, а cookie можно передавать на сервер, однако, куки уже устарели, 
у них множество проблем с безопасностью, и они не способны хранить сложные данные.

d. Поддержка. Локальное и сессионное хранилище не поддерживаются старыми браузерами, например, IE 7 и ниже. Куки поддерживаются очень хорошо старыми браузерами.

Если нам нужно надолго сохранить много пользовательских данных, следует использовать Local Storage.


2. Как добавить и получить значение из веб-хранилища?

Использовать методы localStorage:
метод setItem() — добавляет пару ключ-значение в локальное веб-хранилище;
метод getItem() — получает значение по ключу.

localStorage.setItem('name', 'Маша');
localStorage.getItem('name');

Все, что мы записываем в значение веб-хранилищ, может быть только одного типа - строкового. Поэтому если мы хотим записать туда, например, массив, 
то при сохранении нужно сначала превратить его в строку, а при получении - из строки преобразовать обратно в массив. Сделать это можно при помощи JSON 
(JavaScript Object Notation), это общий формат для представления значений и объектов.

JavaScript предоставляет методы:
JSON.stringify для преобразования объектов в JSON.
JSON.parse для преобразования JSON обратно в объект.


3. Придумайте еще минимум 3 ситуации помимо предложенных в уроке, для чего может быть нужно сохранять данные пользователя и какие? 

- сохранение данных (выбор аватарки, пола, добавление карты и т.д.);
- выбор темы на сайте;
- загрузка медиафайлов.


4. Как сделать валидацию номера кредитной карты?

С помощью регулярного выражения можно отсеять очевидно неподходящие последовательности. Подобная регулярка может поддерживать сразу несколько платежных систем:

/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/


5. Как сделать input, который будет принимать только числа (минимум 2 способа)?

a. Задать <input type="number"> и прописать в скрипте валидацию с помощью объекта validity и свойства typeMismatch. Если пользователь будет вводить в поле не числовое значение, 
typeMismatch вернет false - значение не соответствует указанному атрибуту type.

b. Написать регулярное выражение проверки на число в атрибуте pattern и прописать в скрипте валидацию с помощью объекта validity и свойства patternMismatch. 
Если пользователь будет вводить в поле не числовое значение, patternMismatch вернет false - значение не удовлетворяет шаблону, установленному в атрибуте pattern.


6. Найдите регулярное выражение для ФИО на русском языке

Проверка полных ФИО с двойной Фамилией через тире (с учётом буквы Ё ё):
/^[А-ЯЁ][а-яё]*([-][А-ЯЁ][а-яё]*)?\s[А-ЯЁ][а-яё]*\s[А-ЯЁ][а-яё]*$/


7. Как должно выглядеть невалидное поле, чтобы пользователю было понятно, что в него вводить? Как показать пользователю, что не так, если ввод некорректен 
(теги и атрибуты html, псевдоклассы css)?

Невалидное поле может подсвечиваться либо в нем может появиться сообщение об ошибке. Существует несколько способов валидации:

a. HTML5. 
Этот метод валидации является наиболее поддерживаемым в современных браузерах. И он самый простой - достаточно определить type input поля и расставить атрибуты required, 
которые отвечают за обязательность заполнения. Кроме того, может понадобиться атрибут pattern, который принимает в себя значение регулярного выражения, 
а также атрибуты minlength (не поддерживается старыми браузерами) и maxlength.

Список типов: text, password, submit, reset, radio, checkbox, button, hidden, а также смысловые HTML5 типы: email, tel, url, number, time, date, datetime, datetime-local, 
month, week, range, search, color.

В случае, если поле невалидно, появится системное сообщение (например, «заполните поле» или «отсутствует символ @ в email»). Однако, для более сложных типов (наподобие телефона) 
поясняющие сообщения не предусмотрены, будет написано «введите данные в нужном формате». В этом случае придется рядом с полем ввода описывать необходимый формат, 
чтобы пользователю было понятно. Но без использования масок это не очень удобно.

b. Псевдоклассы.
С помощью псевдоклассов можно выделить цветом валидные и невалидные поля. В CSS существует четыре псевдокласса, применимых к полям формы: 
:valid (валидное поле), :invalid (невалидное), :required (обязательное) и :optional (необязательное). Большой минус этого способа - его ограниченность. 
Проверять мы можем только факт заполнения, но не корректность введенных данных. 

Используя :valid и :invalid можно показать пользователю, правильно ли заполнено поле по мере ввода. Но стили применяются до того, как пользователь начнёт работу с формой. 
Поля, обязательные для заполнения, сразу подсветятся нам как :invalid, а необязательные — как :valid. Пользователь ещё до заполнения формы может получить негативную обратную связь. 

Стилизация состояний :required и :optional  не особо полезна, потому что эта информация обычно указывается в подписях к полям формы. Однако можно объединить все состояния 
и стилизовать их комбинации. Например, мы хотим показывать лишь положительный результат, когда валидно обязательное к заполнению поле.

c. Использование JavaScript с HTML5

JavaScript даёт намного больше возможностей для улучшения работы пользователей с формами. Валидируя поля стандартным способом через HTML5, браузер проверяет их 
по определённому списку потенциальных ошибок. В каждом поле есть специальный объект validity, который включает в себя список булевых значений, характеризующих проверку на валидность. 

validity имеет следующие свойства:
valid: false // Поле валидно 
customError: false // Установленно специальное сообщение ошибки 
patternMismatch: false // Значение не удовлетворяет шаблону, установленному в атрибуте pattern 
rangeOverflow: false // Значение превосходит атрибут max 
rangeUnderflow: true // Значение меньше атрибута min 
stepMismatch: true // Значение не соответствует указаному шагу 
tooLong: false // Значение слишком длинное 
tooShort: false // Значение слишком короткое 
typeMismatch: false // Значение не соответствует указаному атрибуту type 
valueMissing: false // Отсутствует обязательное значение

При использовании JavaScript можно отключить системные сообщения и написать собственные сообщения для пользователей, учитывая все возможные ошибки ввода.

d. Использование JavaScript c регулярными выражениями

Когда не хватает встроенных возможностей, нужно писать свою собственную валидацию через регулярные выражения. Регулярное выражение состоит из шаблона («паттерна») 
и необязательных флагов: g, i, m, y и др.

8. Какие есть недостатки у стандартного способа задания валидации через HTML5?

- удобство для пользователей. Без использования JavaScript может быть довольно сложно объяснить, какой именно формат для ввода значений нужен;
- системные сообщения об ошибках невозможно стилизовать или даже просто изменить их содержание.





Практическое задание


1. Доработать форму-опросник для владельцев котиков из прошлых заданий, сделав для нее валидацию через HTML5. 
(папка cats)

2. Доработать форму регистрации из прошлых заданий, сделав для нее валидацию через JS.
(папка registration)

3. Доработать сохранение комментариев из прошлого домашнего задания через веб-хранилище, дать возможность пользователю сохранять свое имя и аватарку при вводе и запоминать их.
(папка comments)

4. Сделать локальное хранилище заметок для себя любимой. Не забыть валидацию при добавлении заметки.
(папка notes)
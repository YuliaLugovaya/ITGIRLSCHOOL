Неделя 5


Вопросы


1. Почему в большинстве ситуаций стоит использовать flexbox-позиционирование?
Потому что flexbox является самым простым и удобным вариантом в современном мире, а также официально рекомендуется World Wide Web Consortium (W3C).
Flexbox нужен для создания гибких макетов. С помощью этой технологии можно очень просто расставить элементы в контейнере, распределить доступное пространство между ними 
и выровнять их, даже если они не имеют конкретных размеров. С Flexbox можно создать адаптивный дизайн намного проще, чем с использованием блочной модели или float.

2. Самостоятельно изучите способ позиционирования через display: table и ответьте на вопрос, для каких ситуаций оно лучше всего подходит?
CSS-свойство display: table может использоваться для создания таблиц. По сути, CSS-таблица — это имитация HTML-таблицы с тегом <table>, но с помощью CSS-свойств.
	table      { display: table }
	tr           { display: table-row }
	thead     { display: table-header-group }
	tbody     { display: table-row-group }
	tfoot      { display: table-footer-group }
	col         { display: table-column }
	colgroup { display: table-column-group }
	td, th      { display: table-cell }
	caption  { display: table-caption }
	
	У CSS-таблиц есть одно ключевое отличие от HTML-таблиц: они могут перестать быть таблицами, стоит только изменить их CSS-свойства. А HTML-таблицы на такое не способны. 
Это открывает широкие возможности выборочного использования в вёрстке нужных табличных особенностей.
	Важно то, что это действительно полноценная таблица. Используются табличные алгоритмы вычисления ширины и высоты элемента, описанные в стандарте. Это хорошо для 
семантической вёрстки и позволяет избавиться от лишних тегов. Для таблицы целиком нужно прописывать display: table, для строки – table-row, для ячейки – table-cell и т.д. 
Однако, объединения ячеек colspan и rowspan не поддерживаются. 
display: table изначально предназначался для создания таблиц. Со времен табличной верстки в html и css появилось множество улучшений, которые заменяют такую верстку. 
Проблема табличной верстки в том, что с ней сложно добиться адаптивности. Таблицы можно использовать в исключительных случаях по их прямому назначению - для отображения таблиц. 
Однако, display: table может подойти для следующих ситуаций:
- выравнивание по вертикали (по центру) элементов. Внутри ячеек свойство vertical-align выравнивает содержимое по вертикали:
	 display: table-cell;
	 vertical-align: middle;
	 text-align: center;
- горизонтальное расположение по центру элементов (вместо - display: inline-block и text-align: center):
	 display: table; (для родителя)
	 margin: auto (для родителя)
	 display: inline; (для дочернего)

3. Какими способами можно сделать горизонтальное выравнивание по центру? Минимум 3 варианта, можно больше
a. Блочная модель:
	родительский элемент - text-align: center;
	дочерние элементы: display: inline (или inline-block)
b. Способ с flexbox:
	для родительского элемента –
	       display: flex;
	       flex-direction: row;
	       justify-content: center;
с. CSS-таблицы:
	 для родителя
	       display: table;
	       margin: auto;
	   для дочернего
	       display: inline;

4. Какие есть оси во флекс-верстке и как задается их направление?
В Flexbox есть две оси: главная (по умолчанию направлена слева направо) и поперечная (по умолчанию направлена сверху вниз), она перпендикулярна главной. 
Главная ось задаёт основное направление flex-элементов во flex-контейнере, а поперечная ось определяет их направление при переносе на новую линию.
	По умолчанию flex-элементы располагаются вдоль направления главной оси на одной линии. Направление главной оси можно изменить с помощью CSS-свойства flex-direction. 
С помощью этого свойства можно сделать так, чтобы flex-элементы располагались не рядами (rows), а колонками (columns):
	  row (слева направо) - по умолчанию
	  row-reverse (справа налево)
	  column (сверху вниз)
	  column-reverse (снизу вверх)
	
	По умолчанию flex-элементы не переносятся на новую линию, даже если им не хватает места в текущей линии, они выходят за её пределы. Но это можно изменить с помощью установки 
flex-контейнеру свойства flex-wrap:
	  nowrap (только на одной линии - по умолчанию)
	  wrap (разрешить перенос flex-элементов на новые линии)
	  wrap-reverse (осуществлять перенос flex-элементов в обратном порядке)
	Значения wrap и wrap-reverse определяют направление поперечной оси.
	
	Свойства flex-direction и flex-wrap можно указать с помощью универсального свойства flex-flow:
	1 значение - flex-direction, 2 значение - flex-wrap

5. Разберитесь, как работает свойство margin: auto во флекс-верстке, приведите пример использования
margin: auto во флекс-верстке помогает сделать идеальное центрирование.
	Если задать контейнеру display: flex, а дочернему флекс-элементу margin: auto, то получится отцентровать элемент по вертикали и горизонтали так, чтобы центровка 
сохранялась при изменении размеров элемента или контейнера.
	Похожий эффект можно получить, выставив justify-content и align-items на center, когда дочерний элемент остаётся в центре родителя горизонтально и вертикально.
	Но с margin: auto можно экспериментировать, например, так:
	если мы выставим margin-left и margin-top на auto, мы можем спихнуть flex-элемент в нижний правый угол родителя. То есть, выставление свойства margin flex-потомку, 
оттолкнет его в указанном направлении. Выставив margin-left на auto, мы оттолкнем потомка вправо. Выставив margin-top на auto, мы оттолкнем потомка вниз.
	Пример:
	Я уже использую margin: 0 auto для того, чтобы выровнять по центру весь контейнер по макету сайта, если он имеет ширину, например, 1440px, а экран монитора имеет ширину 1920px.

6. В чем преимущества box-sizing?
box-sizing позволяет нам точно определять, как блочная модель работает и как вычисляются размеры элемента – все значения суммируются или включаются в ширину и длину, которые мы задаем. 
Это свойство принимает два основных значения — content-box и border-box.
	Значение content-box является значением по умолчанию, оставляя блочную модель в качестве суммируемой. Размер элемента начинается со свойств width и heigh и к ним добавляются 
значения свойств padding, border или margin. То есть, фактический размер элемента будет больше, чем выставленные значения ширины и длины.
	Значение border-box изменяет блочную модель так, чтобы любые значения свойств border или padding включались внутри width и height элемента. То есть, если для элемента указаны 
width 500px, padding 30px и border 5px вокруг всех сторон, ширина останется 500 пикселей. И если мы хотим, чтобы весь элемент был 500 пикселей в ширину, он останется такого размера 
независимо от того, какие значения padding или border мы к нему добавляем.
	Но независимо от того, какое значение свойства box-sizing применяется, любые значения margin не будут добавляться в вычисления полного размера элемента.

7. Чем отличается flex-grow от flex-shrink?
Главное отличие – это CSS-свойства с противоположным смыслом: flex-grow определяет, может ли начальная ширина flex-элемента увеличиваться, а flex-shrink определяет, может ли ширина 
flex-элемента уменьшиться.
	Увеличение ширины flex-элемента осуществляется за счёт свободного пространства линии. В качестве значения flex-grow указывается целое число. Именно это значение, если оно 
больше или равно 1, определяет, какую часть свободного пространства flex-элемент заберёт себе.
	Уменьшение ширины flex-элемента будет осуществляться только в том случае, если ширины линии будет не достаточно для отображения всех flex-элементов, расположенных в ней. 
Необходимая ширина рассчитывается на основании начальной ширины, которую имеет каждый flex-элемент в ней.

8. Как можно добиться следующего позиционирования элементов:
С помощью следующих css-свойств для flex-контейнера:
	display: flex;
	   flex-direction: row;
	   justify-content: space-between;

9. Какой в итоге будет размер у элемента (можно округлить)?
По ширине:
	134,545 (ширина содержимого) + 5 (padding-left) + 5 (padding-right) + 1,989 (border-left) + 1,989 (border-right) = 148,523 ~ 149
	
	По высоте:
	11,818 (высота содержимого) + 2 (padding-top) + 2 (padding-bottom) + 1,989 (border-top) = 17,807 ~ 18

10. Самостоятельно разберитесь, зачем нужно свойство order?
Свойство order изменяет порядок по умолчанию для flex-элементов, который мы определяем с помощью flex-direction и flex-flow. Он влияет только на визуальное расположение элементов, 
но он не влияет на то, как скринридеры читают исходный код.
Мы используем order для flex-элементов, а не flex-контейнера. Оно может принимать любое целое значение (в том числе отрицательное) и его значение по умолчанию равно 0.
Элементы располагаются согласно значениям свойства order от меньшего к большему. При равных значениях order элементы выводятся в том порядке, в каком они появляются в исходном коде.

11. Каким кодом можно сделать такую таблицу?
С помощью табличной верстки (устаревший вид позиционирования).
	Код будет таким (отправила в слак).

12. Изучите материалы и найдите, для каких ситуаций подходит position: fixed?
По своему действию это значение близко к absolute, но в отличие от него, когда страницу прокручивают, фиксированный элемент остаётся на своём месте и не прокручивается вместе со страницей.
То есть, фиксируется относительно window с помощью свойств left, top, right и bottom.
	Для fixed характерны следующие особенности:
	- при прокрутке веб-страницы элемент остаётся на своём исходном месте;
	- положение элемента всегда отсчитывается от области просмотра браузера независимо от позиционирования родителя;
	- при выходе элемента за пределы видимой области справа или снизу от неё не возникает полос прокрутки и элемент просто «обрезается».
	Применяется fixed для создания меню, вкладок, заголовков - любых элементов, которые должны быть закреплены на веб-странице и всегда видны пользователю.

13. Каким способом лучше всего верстать большие блоки текста?
Для верстки больших блоков текста лучше всего подойдет блочная модель. Flexbow, со всеми его преимуществами, предназначен для создания гибких макетов и быстрой расстановки элементов.

14. Как рассчитывается размер flex-контейнера?
Изначальный размер flex-контейнера зависит от того, какое из двух значений - flex или inline-flex - присвоено свойству display. Значение flex определяет контейнер как блочный элемент, 
а значение inline-flex определяет элемент как строчный. В первом случае flex-контейнер растягивается по ширине страницы, а во втором случае занимает именно столько места, сколько 
необходимо для flex-элементов.
Далее с помощью свойств width, height, padding, border, margin мы можем влиять на размер flex-элементов. А управлять шириной flex-элемента можно при помощи свойства flex 
(flex-grow, flex-shrink и flex-basis).
Именно изменение размеров с помощью позиционирования Flexbox позволяет создавать гибкие макеты, которые полностью адаптируются к экрану. Свойства размеров Flexbox работают 
в трех случаях:
	flex-grow: как должны вести себя flex-элементы при избытке свободного пространства (как они должны растягиваться).
	flex-shrink: как должны вести себя гибкие элементы при нехватке свободного места (как они должны сжиматься).
	flex-basis: как должны вести себя гибкие элементы, когда места ровно столько, сколько нужно.


Практическое задание


1. Пройти игру https://flexboxfroggy.com/ (подтверждение - скриншот 23 или 24 уровня)
- выполнила.

2. Сверстать страничку любым способом, чтобы получить такой результат и прислать ссылку на github
- папка css-flex_page.

3. Полностью доделать страницу из прошлой недели с помощью новых знаний о верстке и Flexbox и прислать ссылку на github
- папка Aperture в week_4.

Дополнительное задание: Если вы хотите еще лучше закрепить свои навыки, попробуйте поиграть в другую игру - http://www.flexboxdefense.com/
- выполнила.